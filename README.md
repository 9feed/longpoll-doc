# User Long Poll API

### План документации:
1. [Подключение](#подключение)
2. [Возвращаемые ошибки](#возвращаемые-ошибки)
3. [Получение устаревшей истории событий](#получение-устаревшей-истории-событий)
4. [Структура событий](#структура-событий)
5. [Дополнительные данные](#дополнительные-данные)

Документация написана для __11__ версии Long Poll.

## Подключение

Long Polling - это способ получения событий в реальном времени используя бесконечную цепочку запрос - ответ - запрос... При подаче запроса сервер возвращает ответ не сразу, а когда придет новое событие или истечет время ожидания.

Ссылку для запроса нужно генерировать следующим образом:

> https://**`server`**?act=a_check&key=**`key`**&ts=**`ts`**&wait=**`wait`**&mode=**`mode`**&version=**`version`**

* `server`, `key` и `ts` получаются один раз методом [`messages.getLongPollServer`](https://vk.com/dev/messages.getLongPollServer)
* `version` - Версия Long Poll
* `wait` - Время ожидания нового события в секундах, максимум 90
* `mode` - Дополнительные опции ответа:
  * `2` - Возвращать вложения
  * `8` - Возвращать нормальные данные некоторых событий
  * `32` - Возвращать `pts`
  * `64` - Возвращать данные о платформе в событии онлайна друга
  * `128` - Возвращать `random_id`

В `Node.js` ссылку можно составить следующим образом:
```js
// server, key и ts нужно получить заранее. 
const link = `https://${server}?` + require('querystring').stringify({
  act: 'a_check',
  key: key,
  ts: ts,
  wait: 10,
  mode: 2 | 8 | 32 | 64 | 128,
  version: 11
});
```

После выполнения запроса сервер вернет ответ следующего вида:
```js
{
  updates?: Array,
  ts?: Number,
  pts?: Number,
  failed?: Number,
  min_version?: Number,
  max_version?: Number
}
```

Затем нужно будет обработать пришедшие в `updates` события и повторить запрос, перед этим заменив `ts` на новый из ответа.

## Возвращаемые ошибки

Иногда вместо поля `updates` в ответе может прийти поле `failed`. В первой половине случаев эта ошибка очень легко решается и не связана с потерей событий (2 и 4), но во второй, чтобы восстановить все "потерянные" события, нужно будет немножко попотеть.

1. Устарела история событий. Решается [получением и обработкой устаревшей истории событий](#получение-устаревшей-истории-событий) и использованием переданного `ts` далее.
2. Истекло время действия ключа. Решается использованием `key` из метода [`messages.getLongPollServer`](https://vk.com/dev/messages.getLongPollServer).
3. Информация о пользователе утрачена. Решается [получением и обработкой устаревшей истории событий](#получение-устаревшей-истории-событий) и использованием `key` и `ts` из метода [`messages.getLongPollServer`](https://vk.com/dev/messages.getLongPollServer).
4. Передана неправильная версия. Вместе с ошибкой передаются поля `min_version` и `max_version`, так что проблем здесь не возникнет.

## Получение устаревшей истории событий

Чтобы получить устаревшую историю событий, нам необходим `pts`, получение которого включается полем `need_pts: 1` в [`messages.getLongPollServer`](https://vk.com/dev/messages.getLongPollServer) и добавлением в `mode` флага `32` при [выполнении запроса](#подключение).

Для получении истории мы будем использовать метод [`messages.getLongPollHistory`](https://vk.com/dev/messages.getLongPollHistory) с указанием следующих параметров при запросе:
- `ts` - последний полученный `ts` из лонгпула
- `pts` - последний полученный `pts` из лонгпула
- `msgs_limit` - минимум `200`, рекомендую `500`
- `max_msg_id` - `id` последнего полученного сообщения из лонгпула
- `onlines` - `1` если возвращать события `8` и `9` (онлайн и оффлайн друга), `0` если нет
- `lp_version` - последняя версия лонгпула
- `fields` - поля [пользователей и групп](https://vk.com/dev/objects/user), которые придут вместе с историей.

Ответ выглядит следующим образом:
```js
{
  history: Array,
  messages: { count: Number, items: Array },
  conversations: Array,
  from_pts: Number,
  new_pts: Number,
  profiles?: Array,
  groups?: Array,
  more?: Number
}
```

Поле `history` идентично полю `updates` в Long Poll, за исключением сокращения некоторых событий:
- `3` - сброс флага сообщения
- `4` - новое сообщение
- `5` - редактирование сообщения
- `18` - добавление сниппета к сообщению

В результате сокращения события будут выглядеть так:
```
[event_id, msg_id, flags, peer_id]
```

Основную информацию о сообщениях и беседах нужно будет брать из полей `messages` и `conversations`.

Рекомендую __НЕ__ обрабатывать `18` событие, потому что в `4` событии сниппет уже будет прикреплен к сообщению. 

Если в ответе придет поле `more`, то после обработки всех событий нужно будет повторить запрос, указав в поле `pts` пришедший `new_pts`, а в поле `max_msg_id` `id` последнего полученного сообщения отсюда.

## Структура событий

## Дополнительные данные
